import serial
import time

# í•˜ë‚˜ì˜ ë³´ë“œë§Œ ì—°ê²°ë¨
serial_port = serial.Serial('COM8', 9600, timeout=1)
time.sleep(2)

# ê±°ë¦¬ ê¸°ì¤€
OBSTACLE_THRESHOLD = 50
RECOVERY_DISTANCE = 100
REQUIRED_CONSECUTIVE_HITS = 3  # ì—°ì† ê°ì§€ íšŸìˆ˜

# ìƒíƒœ ì •ì˜
state = "WAYPOINT_FOLLOWING"
consecutive_hits = 0
steering_time = None
reversing_time = None

def get_distance():
    line = serial_port.readline().decode('utf-8').strip()
    if line:
        try:
            _, dist = line.split(",")
            return float(dist)
        except ValueError:
            print("ê±°ë¦¬ íŒŒì‹± ì‹¤íŒ¨:", line)
    return None

def main():
    global state, consecutive_hits, steering_time, reversing_time

    while True:
        distance = get_distance()
        if distance is None:
            continue

        print(f"\nğŸ“ ì „ë°© ê±°ë¦¬: {distance:.1f} cm | ìƒíƒœ: {state}")

        if state == "WAYPOINT_FOLLOWING":
            print("ğŸš— ì›¨ì´í¬ì¸íŠ¸ ì£¼í–‰ ì¤‘...")
            if distance <= OBSTACLE_THRESHOLD:
                consecutive_hits += 1
                print(f"âš ï¸ ì—°ì† ê°ì§€ íšŸìˆ˜: {consecutive_hits}")
                if consecutive_hits >= REQUIRED_CONSECUTIVE_HITS:
                    print("ğŸ›‘ ì¥ì• ë¬¼ ê°ì§€ â†’ ì •ì§€ ë° í›„ì§„ ì¤€ë¹„")
                    state = "REVERSING"
                    reversing_time = time.time()
                    consecutive_hits = 0
            else:
                consecutive_hits = 0  # ì—°ì† ì‹¤íŒ¨ â†’ ë¦¬ì…‹

        elif state == "REVERSING":
            print("âª í›„ì§„ ì¤‘...")
            if time.time() - reversing_time >= 1.5:
                print("â†ªï¸ ì¡°í–¥ê° íšŒì „ (ìš°íšŒ)")
                state = "STEERING"
                steering_time = time.time()

        elif state == "STEERING":
            print("â†”ï¸ ìš°íšŒ íšŒì „ ì¤‘...")
            if time.time() - steering_time >= 1.5:
                print("âœ… ì¡°í–¥ ë³µêµ¬ â†’ ì›¨ì´í¬ì¸íŠ¸ ë³µê·€")
                state = "WAYPOINT_FOLLOWING"

        time.sleep(0.1)

if __name__ == "__main__":
    main()
