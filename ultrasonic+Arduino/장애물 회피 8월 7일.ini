# ì›¨ì´í¬ì¸íŠ¸ê¸°ë°˜ ì¥ì• ë¬¼ íšŒí”¼
# í˜„ì¬ëŠ” ì„¼ì„œ ê°¯ìˆ˜ì˜ í•œê³„ë¡œ ì¸í•´ ì„¼ì„œ 2ê°œë¡œ ê²€ì¦ ë° ì½”ë“œ ì„¤ê³„ ì§„í–‰ ì¶”í›„ 8ê°œì˜ ì´ˆìŒíŒŒ ì„¼ì„œ ì¤‘ 3ê°œì˜ ì„¼ì„œë¥¼ ì‚¬ìš©í•´ ì „ë°© ì¥ì• ë¬¼ ê°ì§€ ë° íšŒí”¼ ì§„í–‰
# ì›¨ì´í¬ì¸íŠ¸ë¥¼ ë”°ë¼ ì£¼í–‰í•˜ë‹¤ê°€ ì¥ì• ë¬¼ì´ 100cm ì´ë‚´ë¡œ ë“¤ì–´ì˜¤ë©´ ì¢Œ ìš° ì„¼ì„œ ê°’ì„ ë¹„êµí•´ì„œ ê°’ì´ í° ë°©í–¥ìœ¼ë¡œ ì¡°í–¥ê° ìµœëŒ€ ì¡°í–¥ê°(ì„ì˜ ì§€ì •)ìœ¼ë¡œ ë³€ê²½
# ì¡°í–¥ê°ì„ ìˆ˜ì •ë€ ë°©í–¥ì˜ ì„¼ì„œê°’ì´ 200cm ì´í•˜ê°€ ë  ë•Œ ê¹Œì§€ ì „ì§„í•˜ë‹¤ê°€ ì¼ì •ê±°ë¦¬ì— ë„ë‹¬í•˜ë©´ ì •ì§€í•œ í›„ ì¡°í–¥ê°ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™” í•˜ì—¬ ë‹¤ì‹œ ì›¨ì´í¬ì¸íŠ¸ ì£¼í–‰

import serial
import time
import sys
import csv
import os
from datetime import datetime

# ì‹œë¦¬ì–¼ í¬íŠ¸ ì„¤ì •
serial_port = serial.Serial('COM8', 115200, timeout=1)
time.sleep(2)

# ê±°ë¦¬ ê¸°ì¤€
OBSTACLE_DETECT_THRESHOLD = 100      # ì¥ì• ë¬¼ ê°ì§€ ê¸°ì¤€ (cm)
AVOID_TARGET_DISTANCE = 200          # íšŒí”¼ ì „ì§„ ëª©í‘œ ê±°ë¦¬ (ì¡°í–¥ ë°©í–¥ ì„¼ì„œê°’ â‰¤ 200)
AVOID_CONFIRM_COUNT = 5              # ì—°ì† ê±°ë¦¬ ë§Œì¡± íšŸìˆ˜

# ì¡°í–¥ê° ê°’ (ì¸¡ì •í–ˆìœ¼ë‚˜ ê²€ì¦í•˜ì§€ ëª»í•˜ì—¬ ì„ì˜ì§€ì •)
STEERING_RIGHT = 15
STEERING_LEFT = -15

# ìƒíƒœ ì •ì˜
state = "WAYPOINT_FOLLOWING"
avoid_forward_count = 0
steering_direction = 0  # +15 (ì˜¤ë¥¸ìª½), -15 (ì™¼ìª½), 0 (ì¤‘ë¦½)

# ì´ì „ ì¶œë ¥ ë¹„êµìš©
last_left = None
last_right = None
last_state = None
last_count = None

# CSV íŒŒì¼ ìë™ ìƒì„±
def get_unique_filename(base_name):
    index = 1
    while True:
        filename = f"{base_name}_{index}.csv"
        if not os.path.exists(filename):
            return filename
        index += 1

csv_filename = get_unique_filename("wkddoanf")

# CSV ì´ˆê¸°í™”
with open(csv_filename, mode='w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(["Timestamp", "Left(cm)", "Right(cm)", "State", "SteeringDirection", "AvoidCount"])

def log_to_csv(left, right, state, steering_direction, avoid_count):
    timestamp = datetime.now().isoformat()
    with open(csv_filename, mode='a', newline='') as f:
        writer = csv.writer(f)
        writer.writerow([timestamp, left, right, state, steering_direction, avoid_count])

def get_distances():
    """ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ê±°ë¦¬ê°’ ì½ì–´ì˜´"""
    line = None
    while serial_port.in_waiting:
        line = serial_port.readline().decode('utf-8').strip()
    if line:
        try:
            _, left, right = line.split(",")
            return float(left), float(right)
        except ValueError:
            print("ê±°ë¦¬ íŒŒì‹± ì‹¤íŒ¨:", line)
    return None, None

def print_status(left, right, state, count):
    sys.stdout.write(
        f"\rğŸ“ ì™¼ìª½: {left:6.1f} cm | ì˜¤ë¥¸ìª½: {right:6.1f} cm | ìƒíƒœ: {state:<20} | íšŒí”¼ ì¹´ìš´íŠ¸: {count}"
    )
    sys.stdout.flush()

def main():
    global state, avoid_forward_count, steering_direction
    global last_left, last_right, last_state, last_count

    print(f"ğŸ“„ CSV íŒŒì¼ ì €ì¥: {csv_filename}")

    while True:
        left, right = get_distances()
        if left is None or right is None:
            continue

        # ë³€í™”ê°€ ìˆì„ ë•Œë§Œ ì¶œë ¥
        if (left != last_left or right != last_right or
            state != last_state or avoid_forward_count != last_count):
            print_status(left, right, state, avoid_forward_count)
            last_left, last_right = left, right
            last_state = state
            last_count = avoid_forward_count

        # CSV ì €ì¥
        log_to_csv(left, right, state, steering_direction, avoid_forward_count)

        if state == "WAYPOINT_FOLLOWING":
            if left <= OBSTACLE_DETECT_THRESHOLD or right <= OBSTACLE_DETECT_THRESHOLD:
                print("\nğŸ›‘ ì¥ì• ë¬¼ ê°ì§€ë¨ â†’ íšŒí”¼ ì‹œì‘")

                if left > right:
                    steering_direction = STEERING_LEFT
                    print("â†©ï¸ ì™¼ìª½ì´ ë„“ìŒ â†’ ì™¼ìª½ìœ¼ë¡œ ì¡°í–¥")
                elif right > left:
                    steering_direction = STEERING_RIGHT
                    print("â†ªï¸ ì˜¤ë¥¸ìª½ì´ ë„“ìŒ â†’ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì¡°í–¥")
                else:
                    steering_direction = STEERING_RIGHT
                    print("â¡ï¸ ì¢Œìš° ë™ì¼ â†’ ê¸°ë³¸ì ìœ¼ë¡œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì¡°í–¥")

                state = "AVOID_FORWARD"
                avoid_forward_count = 0

        elif state == "AVOID_FORWARD":
            # ì¡°í–¥ ë°©í–¥ì— ë”°ë¼ ê²€ì‚¬í•  ì„¼ì„œ ì„ íƒ
            if steering_direction == STEERING_LEFT:
                relevant_distance = left
                direction_label = "ì™¼ìª½"
            elif steering_direction == STEERING_RIGHT:
                relevant_distance = right
                direction_label = "ì˜¤ë¥¸ìª½"
            else:
                relevant_distance = 9999

            if relevant_distance <= AVOID_TARGET_DISTANCE:
                avoid_forward_count += 1
                print(f"\nğŸš— ì „ì§„ ì¤‘... ({direction_label} ê±°ë¦¬: {relevant_distance:.1f} cm) â†’ ì¹´ìš´íŠ¸: {avoid_forward_count}")
                if avoid_forward_count >= AVOID_CONFIRM_COUNT:
                    print("âœ… íšŒí”¼ ì™„ë£Œ â†’ ì¡°í–¥ê° ì´ˆê¸°í™” ë° ì›¨ì´í¬ì¸íŠ¸ ë³µê·€")
                    steering_direction = 0
                    state = "WAYPOINT_FOLLOWING"
            else:
                avoid_forward_count = 0

        time.sleep(0.1)

    serial_port.close()

if __name__ == "__main__":
    main()
